# 序列化

程序通常（至少）使用两种形式的数据：

1. 在内存中，数据保存在对象，结构体，列表，数组，哈希表，树等中。 这些数据结构针对 CPU 的高效访问和操作进行了优化（通常使用指针）。
2. 如果要将数据写入文件，或通过网络发送，则必须将其编码（encode）为某种自包含的字节序列（例如，JSON 文档）。 由于每个进程都有自己独立的地址空间，一个进程中的指针对任何其他进程都没有意义，所以这个字节序列表示会与通常在内存中使用的数据结构完全不同。

序列化(serialization、marshalling)的过程是指将数据结构或者对象的状态转换成可以存储(比如文件、内存)或者传输的格式(比如网络)。反向操作就是反序列化(deserialization、unmarshalling)的过程。从内存中表示到字节序列的转换称为 编码（Encoding） （也称为序列化（serialization）或编组（marshalling）），反过来称为解码（Decoding）（解析（Parsing），反序列化（deserialization），反编组( unmarshalling））。

# 语言特定的格式

许多编程语言都内建了将内存对象编码为字节序列的支持。例如，Java 有 java.io.Serializable ，Ruby 有 Marshal，Python 有 pickle 等等。许多第三方库也存在，例如 Kryo for Java 。

这些编码库非常方便，可以用很少的额外代码实现内存对象的保存与恢复。但是它们也有一些深层次的问题：

- 这类编码通常与特定的编程语言深度绑定，其他语言很难读取这种数据。如果以这类编码存储或传输数据，那你就和这门语言绑死在一起了。并且很难将系统与其他组织的系统（可能用的是不同的语言）进行集成。
- 为了恢复相同对象类型的数据，解码过程需要**实例化任意类**的能力，这通常是安全问题的一个来源：如果攻击者可以让应用程序解码任意的字节序列，他们就能实例化任意的类，这会允许他们做可怕的事情，如远程执行任意代码。
- 在这些库中，数据版本控制通常是事后才考虑的。因为它们旨在快速简便地对数据进行编码，所以往往忽略了前向后向兼容性带来的麻烦问题。
- 效率（编码或解码所花费的 CPU 时间，以及编码结构的大小）往往也是事后才考虑的。 例如，Java 的内置序列化由于其糟糕的性能和臃肿的编码而臭名昭着。

因此，除非临时使用，采用语言内置编码通常是一个坏主意。

# JSON，XML 和二进制变体

谈到可以被许多编程语言编写和读取的标准化编码，JSON 和 XML 是显眼的竞争者。它们广为人知，广受支持，也“广受憎恶”。 XML 经常被批评为过于冗长和不必要的复杂。 JSON 倍受欢迎，主要由于它在 Web 浏览器中的内置支持（通过成为 JavaScript 的一个子集）以及相对于 XML 的简单性。 CSV 是另一种流行的与语言无关的格式，尽管功能较弱。1987 年曾经的 Sun Microsystems 发布了 XDR。二十世纪九十年代后期，XML 开始流行，它是一种人类易读的基于文本的编码方式，易于阅读和理解，但是失去了紧凑的基于字节流的编码的优势。JSON 是一种更轻量级的基于文本的编码方式，经常用在 client/server 端的通讯中。YAML 类似 JSON，新的特性更强大，更适合人类阅读，也更紧凑。还有苹果系统的 property list。

JSON，XML 和 CSV 是文本格式，因此具有人类可读性（尽管语法是一个热门辩题）。除了表面的语法问题之外，它们也有一些微妙的问题：

- 数字的编码多有歧义之处。XML 和 CSV 不能区分数字和字符串（除非引用外部模式）。 JSON 虽然区分字符串和数字，但不区分整数和浮点数，而且不能指定精度。
- 当处理大量数据时，这个问题更严重了。例如，大于$2^{53}$的整数不能在 IEEE 754 双精度浮点数中精确表示，因此在使用浮点数（例如 JavaScript）的语言进行分析时，这些数字会变得不准确。 Twitter 上有一个大于$2^{53}$的数字的例子，它使用一个 64 位的数字来标识每条推文。 Twitter API 返回的 JSON 包含了两种推特 ID，一个 JSON 数字，另一个是十进制字符串，以此避免 JavaScript 程序无法正确解析数字的问题。
- JSON 和 XML 对 Unicode 字符串（即人类可读的文本）有很好的支持，但是它们不支持二进制数据（不带字符编码(character encoding)的字节序列）。二进制串是很实用的功能，所以人们通过使用 Base64 将二进制数据编码为文本来绕开这个限制。模式然后用于表示该值应该被解释为 Base64 编码。这个工作，但它有点 hacky，并增加了 33％的数据大小。 XML 和 JSON 都有可选的模式支持。这些模式语言相当强大，所以学习和实现起来相当复杂。 XML 模式的使用相当普遍，但许多基于 JSON 的工具嫌麻烦才不会使用模式。由于数据的正确解释（例如数字和二进制字符串）取决于模式中的信息，因此不使用 XML/JSON 模式的应用程序可能需要对相应的编码/解码逻辑进行硬编码。
- CSV 没有任何模式，因此应用程序需要定义每行和每列的含义。如果应用程序更改添加新的行或列，则必须手动处理该变更。 CSV 也是一个相当模糊的格式（如果一个值包含逗号或换行符，会发生什么？）。尽管其转义规则已经被正式指定，但并不是所有的解析器都正确的实现了标准。

尽管存在这些缺陷，但 JSON，XML 和 CSV 已经足够用于很多目的。特别是作为数据交换格式（即将数据从一个组织发送到另一个组织），它们很可能仍然很受欢迎。这种情况下，只要人们对格式是什么意见一致，格式多么美观或者高效就没有关系。让不同的组织达成一致的难度超过了其他大多数问题。

## 二进制编码

对于仅在组织内部使用的数据，使用最小公分母编码格式的压力较小。例如，可以选择更紧凑或更快的解析格式。虽然对小数据集来说，收益可以忽略不计，但一旦达到 TB 级别，数据格式的选择就会产生巨大的影响。

JSON 比 XML 简洁，但与二进制格式一比，还是太占地方。这一事实导致大量二进制编码版本 JSON & XML 的出现，JSON（MessagePack，BSON，BJSON，UBJSON，BISON 和 Smile 等）（例如 WBXML 和 Fast Infoset）。这些格式已经被各种各样的领域所采用，但是没有一个像 JSON 和 XML 的文本版本那样被广泛采用。

这些格式中的一些扩展了一组数据类型（例如，区分整数和浮点数，或者增加对二进制字符串的支持），另一方面，它们没有盖面 JSON / XML 的数据模型。特别是由于它们没有规定模式，所以它们需要在编码数据中包含所有的对象字段名称。也就是说，在下例中的 JSON 文档的二进制编码中，需要在某处包含字符串 userName，favoriteNumber 和 interest。

```json
{
  "userName": "Martin",
  "favoriteNumber": 1337,
  "interests": ["daydreaming", "hacking"]
}
```

我们来看一个 MessagePack 的例子，它是一个 JSON 的二进制编码。下图显示了如果使用 MessagePack 对上例中的 JSON 文档进行编码，则得到的字节序列。前几个字节如下：

1. 一个字节`0x83`表示接下来是**3**个字段（低四位= `0x03`）的**对象 object**（高四位= `0x80`）。 （如果想知道如果一个对象有 15 个以上的字段会发生什么情况，字段的数量塞不进 4 个 bit 里，那么它会用另一个不同的类型标识符，字段的数量被编码两个或四个字节）。
2. 第二个字节`0xa8`表示接下来是**8**字节长的字符串（最高四位= 0x08）。
3. 接下来八个字节是 ASCII 字符串形式的字段名称`userName`。由于之前已经指明长度，不需要任何标记来标识字符串的结束位置（或者任何转义）。
4. 接下来的七个字节对前缀为`0xa6`的六个字母的字符串值`Martin`进行编码，依此类推。

二进制编码长度为 66 个字节，仅略小于文本 JSON 编码所取的 81 个字节（删除了空白）。所有的 JSON 的二进制编码在这方面是相似的。空间节省了一丁点（以及解析加速）是否能弥补可读性的损失，谁也说不准。

![使用MessagePack编码的记录](https://s2.ax1x.com/2020/02/06/1yWWAs.md.png)

# Thrift 与 Protocol Buffers

Apache Thrift 【15】和 Protocol Buffers（protobuf）【16】是基于相同原理的二进制编码库。 Protocol Buffers 最初是在 Google 开发的，Thrift 最初是在 Facebook 开发的，并且在 2007~2008 年都是开源的【17】。 Thrift 和 Protocol Buffers 都需要一个模式来编码任何数据。要在 Thrift 的例 4-1 中对数据进行编码，可以使用 Thrift 接口定义语言（IDL） 来描述模式，如下所示：

```json
struct Person {
    1: required string       userName,
    2: optional i64          favoriteNumber,
    3: optional list<string> interests
}
```

Protocol Buffers 的等效模式定义看起来非常相似：

```proto
message Person {
    required string user_name       = 1;
    optional int64  favorite_number = 2;
    repeated string interests       = 3;
}
```

Thrift 和 Protocol Buffers 每一个都带有一个代码生成工具，它采用了类似于这里所示的模式定义，并且生成了以各种编程语言实现模式的类【18】。您的应用程序代码可以调用此生成的代码来对模式的记录进行编码或解码。 用这个模式编码的数据是什么样的？令人困惑的是，Thrift 有两种不同的二进制编码格式，分别称为 BinaryProtocol 和 CompactProtocol。

## Thrift

先来看看 BinaryProtocol。使用这种格式的编码来编码前例中的消息只需要 59 个字节，如下图所示。

总体来说 Protobuf 序列化和反序列的性能都是比较高的，编码后的数据大小也不错。Protobuf 支持很多语言，比如 C++、C#、Dart、Go、Java、Python、Rust 等，同时也是跨平台的，所以得到了广泛的应用。Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言。
